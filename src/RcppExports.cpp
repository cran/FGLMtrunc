// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <RcppArmadillo.h>
#include <Rcpp.h>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// linearSmPenalty
Rcpp::List linearSmPenalty(const arma::vec& Y, const arma::mat& scalar_mat, const arma::mat& M_aug, double lambda_s);
RcppExport SEXP _FGLMtrunc_linearSmPenalty(SEXP YSEXP, SEXP scalar_matSEXP, SEXP M_augSEXP, SEXP lambda_sSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type scalar_mat(scalar_matSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type M_aug(M_augSEXP);
    Rcpp::traits::input_parameter< double >::type lambda_s(lambda_sSEXP);
    rcpp_result_gen = Rcpp::wrap(linearSmPenalty(Y, scalar_mat, M_aug, lambda_s));
    return rcpp_result_gen;
END_RCPP
}
// linearpiecePathCpp
Rcpp::List linearpiecePathCpp(const arma::vec& Y, int n, const arma::mat& scalar_mat, const arma::mat& M_aug, const arma::vec& warmStart, int nbasis, const arma::vec& weight, double lambda_s, double lambdaStart, int d_active, int p_scalar, int degree, double precision);
RcppExport SEXP _FGLMtrunc_linearpiecePathCpp(SEXP YSEXP, SEXP nSEXP, SEXP scalar_matSEXP, SEXP M_augSEXP, SEXP warmStartSEXP, SEXP nbasisSEXP, SEXP weightSEXP, SEXP lambda_sSEXP, SEXP lambdaStartSEXP, SEXP d_activeSEXP, SEXP p_scalarSEXP, SEXP degreeSEXP, SEXP precisionSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< int >::type n(nSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type scalar_mat(scalar_matSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type M_aug(M_augSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type warmStart(warmStartSEXP);
    Rcpp::traits::input_parameter< int >::type nbasis(nbasisSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type weight(weightSEXP);
    Rcpp::traits::input_parameter< double >::type lambda_s(lambda_sSEXP);
    Rcpp::traits::input_parameter< double >::type lambdaStart(lambdaStartSEXP);
    Rcpp::traits::input_parameter< int >::type d_active(d_activeSEXP);
    Rcpp::traits::input_parameter< int >::type p_scalar(p_scalarSEXP);
    Rcpp::traits::input_parameter< int >::type degree(degreeSEXP);
    Rcpp::traits::input_parameter< double >::type precision(precisionSEXP);
    rcpp_result_gen = Rcpp::wrap(linearpiecePathCpp(Y, n, scalar_mat, M_aug, warmStart, nbasis, weight, lambda_s, lambdaStart, d_active, p_scalar, degree, precision));
    return rcpp_result_gen;
END_RCPP
}
// compute_df_linear
Rcpp::NumericVector compute_df_linear(const Rcpp::NumericVector& d_active_seq, const arma::mat& scalar_mat, const arma::mat& M_aug, double lambda_s, int n);
RcppExport SEXP _FGLMtrunc_compute_df_linear(SEXP d_active_seqSEXP, SEXP scalar_matSEXP, SEXP M_augSEXP, SEXP lambda_sSEXP, SEXP nSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type d_active_seq(d_active_seqSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type scalar_mat(scalar_matSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type M_aug(M_augSEXP);
    Rcpp::traits::input_parameter< double >::type lambda_s(lambda_sSEXP);
    Rcpp::traits::input_parameter< int >::type n(nSEXP);
    rcpp_result_gen = Rcpp::wrap(compute_df_linear(d_active_seq, scalar_mat, M_aug, lambda_s, n));
    return rcpp_result_gen;
END_RCPP
}
// logisticSmPenalty
Rcpp::List logisticSmPenalty(const arma::vec& Y, const arma::mat& scalar_mat, const arma::mat& M_aug, double lambda_s, const arma::vec& warmstart, double precision);
RcppExport SEXP _FGLMtrunc_logisticSmPenalty(SEXP YSEXP, SEXP scalar_matSEXP, SEXP M_augSEXP, SEXP lambda_sSEXP, SEXP warmstartSEXP, SEXP precisionSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type scalar_mat(scalar_matSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type M_aug(M_augSEXP);
    Rcpp::traits::input_parameter< double >::type lambda_s(lambda_sSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type warmstart(warmstartSEXP);
    Rcpp::traits::input_parameter< double >::type precision(precisionSEXP);
    rcpp_result_gen = Rcpp::wrap(logisticSmPenalty(Y, scalar_mat, M_aug, lambda_s, warmstart, precision));
    return rcpp_result_gen;
END_RCPP
}
// logisticpiecePathCpp
Rcpp::List logisticpiecePathCpp(const arma::vec& Y, int n, const arma::mat& scalar_mat, const arma::mat& M_aug, const arma::vec& warmStart, int nbasis, const arma::vec& weight, double lambda_s, double lambdaStart, int d_active, int p_scalar, int degree, double precision);
RcppExport SEXP _FGLMtrunc_logisticpiecePathCpp(SEXP YSEXP, SEXP nSEXP, SEXP scalar_matSEXP, SEXP M_augSEXP, SEXP warmStartSEXP, SEXP nbasisSEXP, SEXP weightSEXP, SEXP lambda_sSEXP, SEXP lambdaStartSEXP, SEXP d_activeSEXP, SEXP p_scalarSEXP, SEXP degreeSEXP, SEXP precisionSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type Y(YSEXP);
    Rcpp::traits::input_parameter< int >::type n(nSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type scalar_mat(scalar_matSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type M_aug(M_augSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type warmStart(warmStartSEXP);
    Rcpp::traits::input_parameter< int >::type nbasis(nbasisSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type weight(weightSEXP);
    Rcpp::traits::input_parameter< double >::type lambda_s(lambda_sSEXP);
    Rcpp::traits::input_parameter< double >::type lambdaStart(lambdaStartSEXP);
    Rcpp::traits::input_parameter< int >::type d_active(d_activeSEXP);
    Rcpp::traits::input_parameter< int >::type p_scalar(p_scalarSEXP);
    Rcpp::traits::input_parameter< int >::type degree(degreeSEXP);
    Rcpp::traits::input_parameter< double >::type precision(precisionSEXP);
    rcpp_result_gen = Rcpp::wrap(logisticpiecePathCpp(Y, n, scalar_mat, M_aug, warmStart, nbasis, weight, lambda_s, lambdaStart, d_active, p_scalar, degree, precision));
    return rcpp_result_gen;
END_RCPP
}
// compute_dim_beta_logistic
double compute_dim_beta_logistic(const arma::mat& U_aDU_a, const arma::mat& hessian);
RcppExport SEXP _FGLMtrunc_compute_dim_beta_logistic(SEXP U_aDU_aSEXP, SEXP hessianSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type U_aDU_a(U_aDU_aSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type hessian(hessianSEXP);
    rcpp_result_gen = Rcpp::wrap(compute_dim_beta_logistic(U_aDU_a, hessian));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_FGLMtrunc_linearSmPenalty", (DL_FUNC) &_FGLMtrunc_linearSmPenalty, 4},
    {"_FGLMtrunc_linearpiecePathCpp", (DL_FUNC) &_FGLMtrunc_linearpiecePathCpp, 13},
    {"_FGLMtrunc_compute_df_linear", (DL_FUNC) &_FGLMtrunc_compute_df_linear, 5},
    {"_FGLMtrunc_logisticSmPenalty", (DL_FUNC) &_FGLMtrunc_logisticSmPenalty, 6},
    {"_FGLMtrunc_logisticpiecePathCpp", (DL_FUNC) &_FGLMtrunc_logisticpiecePathCpp, 13},
    {"_FGLMtrunc_compute_dim_beta_logistic", (DL_FUNC) &_FGLMtrunc_compute_dim_beta_logistic, 2},
    {NULL, NULL, 0}
};

RcppExport void R_init_FGLMtrunc(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
